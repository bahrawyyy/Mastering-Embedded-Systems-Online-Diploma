/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 * Update: Edited to be used in ARM CPU MODES lecture.
 *
 ******************************************************************************
 */


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "Stm32_F103C6_gpio_driver.h"
#include "Stm32_F103C6_EXTI_driver.h"
#include "stm32f103c6.h"
#include "Lcd.h"
#include "KPD_interface.h"

uint16_t IRQ_Flag = 0;




int VAL1 = 0;
int VAL2 = 3;

int VAL3 = 7;
int VAL4 = 0;


int CONTROL_Register_Var = 5;
int IPSR_ISR_NUM = 0;


void EXTI9_CallBack(void){
	IRQ_Flag = 1;
	//	Lcd_ES_tsendString("IRQ EXTI9 occurred");
	//	LCD_ES_tGoTo(1, 4);
	//	Lcd_ES_tsendString("-|_");
	//	wait_ms(2000);
	__asm("MRS %[IPSR_Out], IPSR"
				:[IPSR_Out] "=r" (IPSR_ISR_NUM));
}

int main(void)
{
	// Enable clock
	// RCC_GPIOA_CLK_EN();   // Connected to LCD
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();


	//	Lcd_ES_tInit();
	//	lcd_ES_tclear();


	EXTI_PinConfig_t EXTI_Cfg;
	EXTI_Cfg.EXTI_PIN = EXTI9PB9;
	EXTI_Cfg.TriggerCase = EXTI_Trigger_RISING;
	EXTI_Cfg.P_IRQ_CallBack = EXTI9_CallBack;
	EXTI_Cfg.IRQ_Enable = EXTI_IRQ_Enable;

	MCAL_EXTI_GPIO_Init(&EXTI_Cfg);

	IRQ_Flag = 1;


	// No input or output from C code
	__asm("nop \n\t nop \n\t nop");   // Multi assembly


	// Output from assembly to a C variable (%0: first argumnent met)
	__asm("mov %0,#0xff"
			: "=r"(VAL1));  // first column --> output parameters ("" : Specifier)

	__asm("nop \n\t nop \n\t nop");


	// C variable is an input parameter to assembly mov R0,VAL2
	__asm("mov R0, %0"
			: // Output parameter
			: "r" (VAL2)); // Input parameter (write and read from the general pupose register that will hold the address of the variable)


	__asm("nop \n\t nop \n\t nop");

	// Input & Output (add VAL4, VAL2, VAL3) --> VAL4 is the destination

//	__asm("add %0, %1, %2"
//			: "=r" (VAL4)
//			  : "r" (VAL2),
//				"r" (VAL3));


	// Naming Conventional (Same as the last one)
	__asm("add %[Out0], %[in0], %[in1]"
			:[Out0] "=r" (VAL4)
			 :[in0] "r" (VAL2),
			  [in1] "r" (VAL3));




	__asm("nop \n\t nop \n\t nop");

	// LAB6

	__asm("MRS %[Cont_Out], CONTROL"
			:[Cont_Out] "=r" (CONTROL_Register_Var));


	__asm("nop \n\t nop \n\t nop");




	while(1)
	{
		if(IRQ_Flag)
		{
			// lcd_ES_tclear();
			IRQ_Flag = 0;
		}


	}
}



