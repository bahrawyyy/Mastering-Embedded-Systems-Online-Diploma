/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 * Update: Edited to be used in ARM CPU MODES lecture.
 *
 ******************************************************************************
 */


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "Stm32_F103C6_gpio_driver.h"
#include "Stm32_F103C6_EXTI_driver.h"
#include "stm32f103c6.h"
#include "Lcd.h"
#include "KPD_interface.h"

uint16_t TaskA_Flag, TaskB_Flag ,IRQ_Flag = 0;


extern unsigned int _estack;

#define Task_A_stack_size	100  // 100 Byte
#define Task_B_stack_size	100

// Main stack
unsigned int _S_MSP = &_estack;
unsigned int _E_MSP;


// Process stack for task A
unsigned int _S_PSP_TA;
unsigned int _E_PSP_TA;

// Process stack for task B
unsigned int _S_PSP_TB;
unsigned int _E_PSP_TB;

#define OS_SET_PSP(address) 		__asm volatile("mov r0,%0 \n\t msr psp,r0" : : "r"(address))

#define OS_SWITCH_SP_to_PSP			__asm volatile("mrs r0, CONTROL \n\t orr r0,r0,#0x02 \n\t msr CONTROL, r0")

#define OS_Generate_Exception  	 	__asm volatile("SVC #0x3")

#define OS_SWITCH_SP_to_MSP			__asm volatile("mrs r0, CONTROL \n\t mov r1,#0x05 \n\t and r0,r0,r1 \n\t msr CONTROL, r0")

#define OS_SWITCH_TO_UNPRIVILIGE	__asm volatile("mrs r3,CONTROL \n\t orr r3,r3,#0x01 \n\t msr CONTROL,r3")

#define OS_SWITCH_TO_PRIVILIGE		__asm volatile("mrs r3,CONTROL \n\t lsr r3,r3,#0x1 \n\t lsl r3,r3,#0x1 \n\t msr CONTROL,r3")

typedef enum{
	PRIVILIGE,
	UNPRIVILIGE
}CPU_ACCESS_LEVEL;

//void Switch_CPU_AccessLevel(CPU_ACCESS_LEVEL level)
//{
//	switch(level)
//	{
//	case PRIVILIGE:
//		// Clear bit 0 in control register
//		__asm("mrs r3,CONTROL \n\t"
//				"lsr r3,r3,#0x1 \n\t"
//				"lsl r3,r3,#0x1 \n\t"
//				"msr CONTROL,r3");
//		break;
//
//	case UNPRIVILIGE:
//		__asm("mrs r3,CONTROL \n\t"
//				"orr r3, r3, #0x1 \n\t"
//				"msr CONTROL,r3");
//		break;
//	}
//}


void SVC_Handler()
{
	//Switch_CPU_AccessLevel(PRIVILIGE);
	OS_SWITCH_TO_PRIVILIGE;
}



// Act as the ticker of the OS
void EXTI9_CallBack(void){
	if(IRQ_Flag == 0){
		TaskA_Flag = 1;
		IRQ_Flag = 1;
	}else if(IRQ_Flag == 1){
		TaskB_Flag = 1;
		IRQ_Flag = 0;
	}
}

int TaskA(int a, int b, int c){
	return(a+b+c);
}


int TaskB(int a, int b, int c, int d){
	return(a+b+c+d);
}


void Main_OS()
{
	// Full descending stack

	// MSP
	_E_MSP = (_S_MSP - 512);   // 512 for MSP

	// PSP for Task A
	_S_PSP_TA = (_E_MSP - 8);
	_E_PSP_TA = _S_PSP_TA - Task_A_stack_size;

	// PSP for Task B
	_S_PSP_TB = (_E_PSP_TA - 8);
	_E_PSP_TB = _S_PSP_TB - Task_B_stack_size;


	// Dummy schedular
	while(1){
		__asm("NOP");
		if(TaskA_Flag == 1){
			// Set PSP register to point to the top of taskA_stack (_S_PSP_TA)
			OS_SET_PSP(_S_PSP_TA);

			// Set SP to shadow to PSP
			OS_SWITCH_SP_to_PSP;


			// Switch to user mode (unprevilige)
			//Switch_CPU_AccessLevel(UNPRIVILIGE);
			OS_SWITCH_TO_UNPRIVILIGE;


			TaskA_Flag = TaskA(1,2,3);


			// Switch to (previlige) .. via syscall, the processor will interrupt itself
			OS_Generate_Exception;

			// Set SP to shadow to MSP
			OS_SWITCH_SP_to_MSP;

		}else if(TaskB_Flag == 1){
			// Set PSP register to point to the top of taskB_stack (_S_PSP_TB)
			OS_SET_PSP(_S_PSP_TB);

			// Set SP to shadow to PSP
			OS_SWITCH_SP_to_PSP;



			// Switch to user mode (unprevilige)
			//Switch_CPU_AccessLevel(UNPRIVILIGE);
			OS_SWITCH_TO_UNPRIVILIGE;


			TaskB_Flag = TaskB(1,2,3,4);


			// Switch to (previlige)
			OS_Generate_Exception;

			// Set SP to shadow to MSP
			OS_SWITCH_SP_to_MSP;

		}
	}


}

int main(void)
{
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();



	EXTI_PinConfig_t EXTI_Cfg;
	EXTI_Cfg.EXTI_PIN = EXTI9PB9;
	EXTI_Cfg.TriggerCase = EXTI_Trigger_RISING;
	EXTI_Cfg.P_IRQ_CallBack = EXTI9_CallBack;
	EXTI_Cfg.IRQ_Enable = EXTI_IRQ_Enable;

	MCAL_EXTI_GPIO_Init(&EXTI_Cfg);

	// Main OS
	Main_OS();


	//IRQ_Flag = 1;

//	Switch_CPU_AccessLevel(UNPRIVILIGE);
//
//
//	Switch_CPU_AccessLevel(PRIVILIGE);

//	while(1)
//	{
////		if(IRQ_Flag)
////		{
////			IRQ_Flag = 0;
////		}
//
//
//	}
}



