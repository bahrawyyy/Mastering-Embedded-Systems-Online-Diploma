/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "Stm32_F103C6_gpio_driver.h"
#include "FreeRTOS.h"
#include "FreeRTOSConfig.h"
#include "task.h"
#include "semphr.h"


// Handles

TaskHandle_t vTaskButtonHandle = NULL;
TaskHandle_t vTaskLedHandle = NULL;
SemaphoreHandle_t xSemaphore = NULL;


// Tasks Prototypes
void vTaskButtonHandler(void * params);
void vTaskLedHandler(void * params);


// Variables (Current, Previous) for monitoring button state
uint8_t Button_CurrentState = 0;
uint8_t Button_PreviousState = 0;


void HW_INIT(void)
{
	// Initialize Output pin (Led) --> Pin13
	GPIO_PinConfig_t PIN13CFG;
	PIN13CFG.GPIO_PinNumber = GPIO_PIN_13;
	PIN13CFG.GPIO_MODE = GPIO_MODE_OUTPUT_PUSHPULL;
	PIN13CFG.GPIO_OUTPUT_SPEED = GPIO_SPEED_10MHZ;
	MCAL_GPIO_Init(GPIOC, &PIN13CFG);

	// Initialize Input pin (Button) --> Pin15
	GPIO_PinConfig_t PIN15CFG;
	PIN15CFG.GPIO_PinNumber = GPIO_PIN_15;
	PIN15CFG.GPIO_MODE = GPIO_MODE_INPUT_PULLDOWN;
	MCAL_GPIO_Init(GPIOC, &PIN15CFG);
}



int main(void)
{
	RCC_GPIOC_CLK_EN();
	HW_INIT();

	// Tasks Creation
	xTaskCreate(vTaskButtonHandler, "Button_Task", 128, NULL, 1, &vTaskButtonHandle);
	xTaskCreate(vTaskLedHandler, "Led_Task", 128, NULL, 2, &vTaskLedHandle);

	// Semaphore creation
	xSemaphore = xSemaphoreCreateBinary();


	vTaskStartScheduler();



	while(1)
	{

	}


	return 0;
}



void vTaskButtonHandler(void * params)
{
	while(1)
	{
		Button_CurrentState = MCAL_GPIO_ReadPin(GPIOC, GPIO_PIN_15);

		// The task will give the semaphore if only there is a change in the button state
		if(Button_CurrentState != Button_PreviousState)
		{
			// Give semaphore
			xSemaphoreGive(xSemaphore);
		}

		Button_PreviousState = Button_CurrentState;

		// Check the button each 25 ticks
		vTaskDelay(25);
	}
}


void vTaskLedHandler(void * params)
{
	while(1)
	{
		// This task will take the semaphore if the button task gave it (A change happened)
		if(xSemaphoreTake(xSemaphore, (TickType_t) 5) == pdTRUE)
		{
			if(Button_CurrentState == GPIO_PIN_HIGH)
			{
				MCAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_HIGH);
			}else{
				MCAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_LOW);
			}

		}
		vTaskDelay(30);
	}
}
